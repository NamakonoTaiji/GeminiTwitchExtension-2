# Gemini Twitch Translator - リファクタリング計画

## 1. 概要

このドキュメントでは、Gemini Twitch Translator拡張機能のコードベースを改善するための詳細なリファクタリング計画を定義します。リファクタリングの目的は、コードの保守性、可読性、拡張性を向上させることです。

## 2. 現状の課題

現在のコードベースには、以下の課題があります：

1. **コード重複**: 同様の機能が複数の場所に実装されている
2. **責務の不明確さ**: 特に`content.js`と`content_loader.js`の役割が重複している
3. **命名の不統一**: ファイル、関数、変数の命名規則にばらつきがある
4. **型情報の欠如**: データ構造や関数の型が明示されていない
5. **エラーハンドリングの不統一**: 各モジュールで異なるエラー処理手法が使われている
6. **テスト不足**: 自動テストがなく品質担保が難しい

## 3. リファクタリングの目標

1. **コードの一貫性向上**: 命名規則や実装パターンの統一
2. **モジュール間の責務明確化**: 各ファイルの役割と責務の明確な定義
3. **型安全性の向上**: 主要なデータ構造と関数の型定義の追加
4. **エラーハンドリングの統一**: 一貫したエラー処理メカニズムの実装
5. **テスト容易性の向上**: テスト可能な設計への改善
6. **ドキュメント整備**: コード内ドキュメントとAPI説明の充実

## 4. リファクタリング方針

リファクタリングは「安全なステップ」で進めます：

1. **小さな変更**: 一度に大きく変更せず、小さなステップで進める
2. **後方互換性**: 機能を壊さず、既存の動作を維持する
3. **段階的改善**: 全てを一度に完璧にするのではなく、段階的に改善する
4. **テストと確認**: 変更ごとに動作確認を行う

## 5. 優先度と実装フェーズ

リファクタリングは優先度に基づいて以下のフェーズで実行します：

### 5.1 フェーズ1: コンテンツスクリプト整理（優先度：最高）

**目的**: `content.js`と`content_loader.js`の統合と役割明確化

**タスク**:
1. `content.js`、`content_loader.js`、`content_refactored.js`の責務を分析
2. 重複コードとそれぞれの強みを特定
3. 新しい構造を`content_new.js`として実装
4. モジュール分割パターンを適用
5. 動作確認後、古いファイルを削除し新ファイルをリネーム

**具体的な実装手順**:
```
1. content_new.js をエントリーポイントとして作成
2. 主要機能を以下のモジュールに分離:
   - chatObserver.js: チャット監視機能
   - messageDetector.js: メッセージ検出ロジック
   - translationDisplay.js: 翻訳表示処理
   - contentController.js: 全体のフロー制御
3. 既存の2つのファイルから機能を統合
4. manifest.json を更新して新しいエントリーポイントを指定
5. テスト後に古いファイルを削除
```

**成功基準**:
- すべての機能が新構造で正常に動作する
- コード行数が25%以上削減される
- 責務が明確に分離されている

### 5.2 フェーズ2: 型定義の導入（優先度：高）

**目的**: 型定義の追加によるコードの堅牢性と可読性の向上

**タスク**:
1. `types.js`ファイルの作成
2. 主要なデータ構造（設定、翻訳結果など）の型定義作成
3. すべての公開関数のJSDoc型注釈追加
4. IDEでの型チェックサポート追加

**具体的な実装手順**:
```
1. shared/types.js ファイルを作成
2. 以下の型定義を実装:
   - TranslationResult
   - Settings
   - MessageType
   - ErrorType
   - CacheEntry
   - Stats
3. JSDoc形式の型注釈を各関数に追加
4. IDEの型チェックを有効化（VSCode設定など）
```

**成功基準**:
- すべての主要オブジェクトが型定義されている
- 公開関数が型注釈付きのドキュメント付けされている
- IDEの型チェックでエラーが検出されない

### 5.3 フェーズ3: エラーハンドリングの統一（優先度：高）

**目的**: 一貫したエラー処理メカニズムの実装

**タスク**:
1. `errorHandler.js`の強化
2. エラータイプの列挙定義
3. エラー作成ユーティリティの実装
4. ユーザーフレンドリーなエラーメッセージマッピング
5. エラーリカバリーメカニズムの実装

**具体的な実装手順**:
```
1. utils/errorHandler.js を強化
2. 以下のエラータイプを定義:
   - NETWORK_ERROR
   - API_ERROR
   - AUTH_ERROR
   - RATE_LIMIT_ERROR
   - PARSE_ERROR
   - DOM_ERROR
   - CONTEXT_INVALIDATED_ERROR
   - STORAGE_ERROR
3. createError(type, message, data) 関数の実装
4. handleError(error, context) 関数の実装
5. 各モジュールでエラーハンドラを適用
```

**成功基準**:
- すべてのエラーが統一された方法で処理される
- ユーザーに表示されるエラーメッセージが明確
- エラーのログ記録と報告が一貫している

### 5.4 フェーズ4: 共通ユーティリティの整理（優先度：中）

**目的**: 重複コードの削減と共通機能の整理

**タスク**:
1. `utils`ディレクトリのモジュール整理
2. 命名規則の統一
3. インターフェースの整理
4. ドキュメントの充実

**具体的な実装手順**:
```
1. ユーティリティ関数の使用状況を分析
2. 次のカテゴリに整理:
   - asyncUtils.js: 非同期関連ユーティリティ
   - domUtils.js: DOM操作ユーティリティ
   - storageUtils.js: ストレージ操作ユーティリティ
   - languageUtils.js: 言語処理ユーティリティ
   - stringUtils.js: 文字列操作ユーティリティ
3. モジュールごとにPublic APIをJSDocで明確に定義
4. インターフェースを設計文書に合わせて統一
```

**成功基準**:
- ユーティリティ関数が明確に分類されている
- インターフェースがドキュメント化されている
- 重複コードが排除されている

### 5.5 フェーズ5: バックグラウンドスクリプト最適化（優先度：中）

**目的**: バックグラウンドスクリプトの効率化とモジュール関係の最適化

**タスク**:
1. メッセージハンドラの分離
2. 初期化順序の最適化
3. エラーハンドリングの強化
4. 動的インポート問題の解決

**具体的な実装手順**:
```
1. messageHandlers.js モジュールの作成
2. 初期化関数の依存関係グラフを作成
3. 初期化の同期を最適化
4. Service Worker環境の制約に対応（動的インポート回避）
5. キャッシュとストレージのパフォーマンス最適化
```

**成功基準**:
- バックグラウンドスクリプトの起動が最適化される
- メッセージハンドリングが明確に分離される
- Service Worker制約に完全に対応する

### 5.6 フェーズ6: テスト導入（優先度：中）

**目的**: 自動テストの導入によるコード品質の向上

**タスク**:
1. テストフレームワーク選定（Jest/Mocha）
2. ユニットテスト用モック実装
3. 主要ロジックのテスト作成
4. CIテスト環境の設定

**具体的な実装手順**:
```
1. テスト設定ファイル(jest.config.js)の作成
2. モックフレームワークの設定
3. 以下の優先領域のテスト実装:
   - 言語判定ロジック
   - 設定管理
   - キャッシュ管理
   - 翻訳処理
4. テスト実行スクリプトの追加
```

**成功基準**:
- コアロジックのテストカバレッジが70%以上
- 全テストが安定して実行できる
- 新機能追加時のリグレッションテスト体制が整う

### 5.7 フェーズ7: UI改善（優先度：低）

**目的**: ユーザーインターフェースの一貫性と使いやすさの向上

**タスク**:
1. ポップアップUIの改善
2. オプションページの整理
3. エラー表示の改善
4. 統計情報表示の改善

**具体的な実装手順**:
```
1. UIコンポーネントの分離を促進
2. 状態変更の通知メカニズムを改善
3. 視覚的なエラーフィードバックを強化
4. 初回起動ガイドなどの実装
```

**成功基準**:
- ユーザーインターフェースの一貫性が向上
- エラー状態がユーザーに明確に伝わる
- 統計情報がわかりやすく表示される

## 6. 命名規則の統一

以下の命名規則を全コードベースで適用します：

### 6.1 ファイル命名

- **モジュールファイル**: キャメルケース (例: `translationHandler.js`)
- **ユーティリティファイル**: キャメルケース (例: `stringUtils.js`)
- **定数/型ファイル**: キャメルケース (例: `errorTypes.js`)
- **ドキュメントファイル**: ケバブケース (例: `user-guide.md`)

### 6.2 関数命名

- **初期化関数**: `init` または `initialize` プレフィックス (例: `initCache()`)
- **取得関数**: `get` プレフィックス (例: `getSettings()`)
- **設定関数**: `set` プレフィックス (例: `setEnabled()`)
- **更新関数**: `update` プレフィックス (例: `updateStatus()`)
- **イベントハンドラ**: `handle` プレフィックス (例: `handleMessage()`)
- **変換関数**: 動詞 + 名詞 (例: `translateText()`)
- **ユーティリティ関数**: 動詞 + 目的 (例: `extractMessageId()`)
- **ブール関数**: `is`, `has`, `should` プレフィックス (例: `isValidMessage()`)

### 6.3 変数命名

- **定数**: 大文字スネークケース (例: `MAX_CACHE_SIZE`)
- **変数**: キャメルケース (例: `messageCount`)
- **プライベート変数**: アンダースコアプレフィックス (例: `_internalState`)
- **DOM要素変数**: 接尾辞に要素タイプ (例: `statusElement`)
- **コレクション**: 複数形 (例: `messages`, `userSettings`)

## 7. コーディング規約

### 7.1 一般規約

- インデントはスペース2文字
- 行の最大長は100文字
- セミコロンは必須
- 空行は関連コードブロックを分離するのに使用
- コメントは「なぜ」に焦点を当てる（コードは「何を」説明）

### 7.2 ES Modules

- `import`と`export`を一貫して使用
- 相対パスを使用（`../`など）
- 名前付きエクスポートを優先
- 循環依存を避ける

### 7.3 非同期処理

- `async/await`を優先
- Promise chainingは短い場合のみ
- エラーハンドリングは`try-catch`で統一
- 非同期関数は接尾辞に`Async`を付けない（慣習に従う）

### 7.4 コメント

- JSDocスタイルのAPIドキュメント
- 複雑なロジックには説明コメント
- TODOコメントには課題番号を含める
- コメントは最新の状態を維持する

## 8. コードレビュー基準

コードレビューでは以下の点を確認します：

1. **機能性**: 実装が要件を満たしているか
2. **保守性**: コードが読みやすく、理解しやすいか
3. **一貫性**: 命名規則とコーディング規約に従っているか
4. **効率性**: 効率的なアルゴリズムとデータ構造を使用しているか
5. **堅牢性**: エラーケースに適切に対応しているか
6. **テスト**: 適切なテストがあるか
7. **ドキュメント**: 必要なドキュメントがあるか

## 9. リファクタリングのリスクと緩和策

### 9.1 リスク

1. **機能の中断**: リファクタリング中に機能が停止する
2. **隠れたバグ**: 既存のバグが表面化する
3. **パフォーマンス影響**: パフォーマンスが低下する
4. **開発遅延**: リファクタリングに予想以上の時間がかかる

### 9.2 緩和策

1. **段階的アプローチ**: 一度に大きな変更を避ける
2. **テスト強化**: 変更前後でテストを行う
3. **バックアップ**: 重要な変更前にはコードをバックアップ
4. **モニタリング**: パフォーマンス指標を監視
5. **タイムボックス**: リファクタリングのタイムボックスを設定

## 10. タスク管理

各フェーズのタスクは以下の流れで管理します：

1. **分析**: 現状コードの分析とリファクタリング計画の詳細化
2. **実装**: コード変更の実装
3. **テスト**: 機能とリグレッションのテスト
4. **レビュー**: コードレビューとフィードバック
5. **調整**: フィードバックに基づく調整
6. **マージ**: 変更のマージと確認

## 11. コミットガイドライン

コミットメッセージは以下の形式に従います：

```
[コンポーネント] タイトル

詳細な説明（必要な場合）

関連タスク: #タスク番号
```

例:
```
[ContentScript] チャットメッセージ検出ロジックをリファクタリング

- メッセージ検出を専用モジュールに分離
- セレクタの優先順位を明確化
- 検出失敗時のフォールバック処理を強化

関連タスク: #42
```

## 12. リファクタリング成功指標

リファクタリングの成功は以下の指標で評価します：

1. **コード行数削減**: 重複を排除したことによるコード量の削減
2. **エラー率低下**: ユーザーから報告されるエラーの減少
3. **開発速度向上**: 新機能追加にかかる時間の短縮
4. **テストカバレッジ**: 自動テストのカバレッジ向上
5. **コード品質指標**: 静的解析ツールによる品質スコアの向上

## 13. まとめ

このリファクタリング計画は、Gemini Twitch Translator拡張機能のコードベースを段階的に改善するためのロードマップです。計画に従って実装することで、コードベースの品質、保守性、拡張性が向上します。

各フェーズは順番に実装されますが、緊急の問題や依存関係に応じて優先順位は調整される可能性があります。リファクタリング中も機能の安定性を最優先し、ユーザー体験を損なわないように注意します。
